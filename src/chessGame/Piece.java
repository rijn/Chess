package chessGame;

import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Super piece class
 */
public class Piece {
    /**
     * Full name of current piece
     */
    public String name = "UNKNOWN";
    // TODO: shortName could also be String cause we're converting it into string below
    /**
     * Short name of current piece
     */
    public char shortName = 'U';

    /**
     * Piece color
     */
    public PieceColor color = PieceColor.BLACK;

    /**
     * Event map for subscriber design pattern
     * Proper events may be called by the Board when event happens
     */
    public Map<String, Vector<Supplier<Piece>>> events = new HashMap<String, Vector<Supplier<Piece>>>();

    /**
     * Log every movements current piece have
     */
    public List<Movement> moveLog = new Vector<Movement>();

    /**
     * Move piece to target location.
     * May apply to more events such at beforeMove or afterMove in the future.
     *
     * @param move The location that wish to be moved to
     */
    public void moveTo(Movement move) {
        moveLog.add(move);
    }

    /**
     * Function that returns current location.
     *
     * @return Movement Current location
     */
    public Movement currentMovement() {
        return moveLog.get(moveLog.size() - 1);
    }

    /**
     * Get all available movements from a base location.
     * Will collect results from two helper functions.
     * TODO: base is no longer needed
     *
     * @param base Base Location
     * @param board The board that wish to be inspect on
     * @return List<Movement> All possible movements
     */
    public List<Movement> getAvailableMovements(Movement base, Board board) {
        return Stream.concat(
                getAvailableMovementsFromPresets(base).stream(),
                getAvailableMovementsFromFactors(base, board).stream()
        ).collect(Collectors.toList());
    }

    /**
     * Available offset movements
     */
    List<Movement> presetMovements;

    /**
     * presetMovements stands for all differential movements that the piece may have.
     * e.g. Knight have 8 possible movements around itself.
     *
     * getAvailableMovementsFromPresets will calculate target location based on current location
     * and filter valid locations.
     *
     * @param base Base Location
     * @return List<Movement> All possible movements
     */
    public List<Movement> getAvailableMovementsFromPresets(Movement base) {
        List<Movement> output = new Vector<Movement>();
        if (presetMovements == null) {
            return output;
        }
        // deep copy the movements list
        for (Movement item : presetMovements) output.add((Movement) item.clone());
        // move it and test if it is valid
        output = output.stream()
                .map(m -> m.move(base))
                .filter(Movement::valid)
                .collect(Collectors.toList());
        return output;
    }

    /**
     * Available factor movements
     */
    Integer[][] factorMovements;

    /**
     * factorMovements means movements generated by a integer times presets factors.
     * e.g. Bishop can go vertical or horizontal by multiplying integers by (0, 1) or (1, 0)
     *
     * getAvailableMovementsFromFactors will calculate that movements and collect valid movements.
     * Pieces cannot move across other pieces, so the calculation process will be terminated when it touch anything.
     *
     * @param base Base Location
     * @param board The board that wish to be inspect on
     * @return List<Movement> All possible movements
     */
    public List<Movement> getAvailableMovementsFromFactors(Movement base, Board board) {
        if (factorMovements == null) {
            return new Vector<Movement>();
        }
        return Arrays.asList(factorMovements)
                .stream()
                .map((factor) -> {
                    List<Movement> oneDirection = new Vector<Movement>();
                    // for every factor, multiply it by 1 to 8
                    IntStream.range(1, Math.max(Constant.BOARD_SIZE_X, Constant.BOARD_SIZE_Y)).boxed().collect(Collectors.toList()).stream()
                            .map(i -> new Movement(factor[0] * i, factor[1] * i).move(base))
                            .filter(Movement::valid)
                            // if touch any piece, stop
                            .anyMatch(m -> {
                                if (board.getPiece(m) == null || board.getPiece(m).color != this.color) {
                                    oneDirection.add(m);
                                }
                                return board.getPiece(m) != null;
                            });
                    return oneDirection;
                })
                // collect all the results
                .reduce(new Vector<Movement>(), (List<Movement> collection, List<Movement> current) -> {
                    collection.addAll(current);
                    return collection;
                });
    }

    /**
     * willOccupyWhenConflict takes one pieces as an argument and returns a boolean that be true if current piece will
     * occupy the target piece. This function may be overrided by specific piece.
     *
     * @param target Target piece that will be occupied
     * @return boolean A boolean that is true if current piece will occupy that space
     */
    public boolean willOccupyWhenConflict(Piece target) {
        return !(target != null && this.color == target.color);
    }
}
